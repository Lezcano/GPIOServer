#!/usr/bin/perl
#
########################################################################################################################
########################################################################################################################
##
##      Copyright (C) 2020 Peter Walsh, Milford, NH 03055
##      All Rights Reserved under the MIT license as outlined below.
##
##  FILE
##
##      GPIOServer
##
##  DESCRIPTION
##
##      RasPi configuration server
##
##      Accept commands from a web socket and perform that function.
##
##  USAGE
##
##      GPIOServer [-v]
##
##      where:      -v      Verbose: print out things as they happen
##
##      $GPIOConfig->
##          {GPIO#}->'5'
##              {Mode}  ->[ 'input', 'output',  ],
##              {Value} ->[ 0, 1 ],                 # Current value
##              {Invert}->[ T, F ],                 # If TRUE, logic is inverted
##              {Device}->...                       # WiringPi struct for device
##
########################################################################################################################
########################################################################################################################
##
##  MIT LICENSE
##
##  Permission is hereby granted, free of charge, to any person obtaining a copy of
##    this software and associated documentation files (the "Software"), to deal in
##    the Software without restriction, including without limitation the rights to
##    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
##    of the Software, and to permit persons to whom the Software is furnished to do
##    so, subject to the following conditions:
##
##  The above copyright notice and this permission notice shall be included in
##    all copies or substantial portions of the Software.
##
##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
##    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
##    PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
##    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
##    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
##    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
##
########################################################################################################################
########################################################################################################################

use strict;
use warnings;
use Carp;

our $VERSION = 'GPIOServer2020-10-20';

use JSON;
use Data::Dumper;
use File::Slurp qw(read_file);

use lib "$ENV{HOME}/GPIOServer/lib";

use Site::WSServer;
use Site::ParseData;

########################################################################################################################
########################################################################################################################
##
## Data declarations
##
########################################################################################################################
########################################################################################################################

our $SERVER_PORT = 2021;

our $Server;
our $GPIOConfig;

#  #
#  # Comment
#  #
#  AllowAdd no                 # When yes, config allows user to add to this file
#
#  GPIO    7
#      Mode=Input              # One of:   Input   Output
#      Logic=Invert            #           Invert  Normal
#      Pull=High               #           High    Low
#      Name="Keurig"
#      Comment="Coffee maker in the kitchen"
#
our $GPIOConfigFile = "$ENV{HOME}/GPIOServer/etc/GPIO.conf";
our $GPIOMatches = [
    {                     RegEx  => qr/^\s*#/                                        , Action => Site::ParseData::SkipLine   }, # Skip Comments
    { Name => "AllowAdd", RegEx  => qr/^\s*(AllowAdd)\s*(yes|no|Yes|No)/             ,Action => Site::ParseData::AddGlobal   },
    {                     RegEx  => qr/^\s*GPIO\s*(\d+)/i                            ,Action => Site::ParseData::StartSection},
    { Name => "Mode"    , RegEx => qr/^\s*Mode\s*=\s*(input|Input|output|Output)/i   ,Action => Site::ParseData::AddVar      },
    { Name => "Logic"   , RegEx => qr/^\s*Logic\s*=\s*(normal|Normal|invert|Invert)/i,Action => Site::ParseData::AddVar      },
    { Name => "Pull"    , RegEx => qr/^\s*Pull\s*=\s*(high|High|low|Low)/i           ,Action => Site::ParseData::AddVar      },
    { Name => "Boot"    , RegEx => qr/^\s*Boot\s*=\s*(on|On|off|Off)/i               ,Action => Site::ParseData::AddVar      },
    { Name => "Name"    , RegEx => qr/^\s*Name\s*=\s*"(.*)"/i                        ,Action => Site::ParseData::AddVar      },
    { Name => "Comment" , RegEx => qr/^\s*Comment\s*=\s*"(.*)"/i                     ,Action => Site::ParseData::AddVar      },
    ];


########################################################################################################################
########################################################################################################################
##
## GPIO server
##
########################################################################################################################
########################################################################################################################

#
# Process command line args.
#
#     -v (verbose) means "print out extra stuff"
#
my $Verbose = 0;

$Verbose = 1
    if defined $ARGV[0] and $ARGV[0] eq "-v";

$GPIOConfig = GetGPIOConfig();

print Data::Dumper->Dump([$GPIOConfig],["GPIOConfig"]);
exit(0);

########################################################################################################################
########################################################################################################################
#
# Setup a web socket and listen for connections.
#
Message("GPIOServer is up and running.")
    if $Verbose;

Message("Waiting for websocket connection")
    if $Verbose;

Site::WSServer::InitWSServer($SERVER_PORT,[],\&WebRequest,\&ConnectionRequest)->start;

exit(1);

########################################################################################################################
########################################################################################################################
#
# ConnectionRequest - Process incoming connection requests
#
# Inputs:      Connection
#              Server
#
# Outputs:     TRUE  if should accept this request
#              FALSE if should reject this request
#
sub ConnectionRequest {

#     kill "USR1",getppid         # Inform server of activity
#         unless $DB::single;     #   (but not if debugging)

    return 1;
    }


########################################################################################################################
########################################################################################################################
# 
#  WebRequest - Process incoming web page requests
# 
#  Inputs:      JSON encoded struct of request
#               Connection
#               Server
# 
#  Outputs:     None
# 
sub WebRequest {
    my $JSONText = shift // "";
    my $Conn     = shift;
    my $Server   = shift;
    
    kill "USR1",getppid         # Inform server of activity
        unless $DB::single;     #   (but not if debugging)

    #
    # Lots of error checking for web requests.
    #
    return Message("ConfigServer: No Web request")
        unless length $JSONText;

    my $Request = eval{decode_json $JSONText};              # Catches/avoids Croak() in lib function

    return Message("ConfigServer: Bad JSON Web request: ($JSONText)")
        unless defined $Request && (ref $Request) eq "HASH";

    $Request->{Type} //= "";
        
    return Message("WebRequest: No request type: ($JSONText)")
        unless length $Request->{Type};

    #
    # GetGPIOConfig - Return the complete GPIO configuration struct
    #
    if( $Request->{Type} eq "GetGPIOConfig" ) {
        $Request->{Error} = "No error.";
        Message("ConfigServer: GetGPIOConfig()")
            if $Verbose;
        $Request->{State} = $GPIOConfig;
        }

    #
    # SetGPIOConfig - Implement new GPIO configuration
    #
    elsif( $Request->{Type} eq "SetGPIOConfig" ) {
        $Request->{Error} = "No error.";
        Message("ConfigServer: SetGPIOConfig()")
            if $Verbose;
        SetGPIOConfig($Request->{Arg1},$GPIOConfig,$Verbose);
        }

    #
    # SetGPIO - Set a GPIO output
    #
    elsif( $Request->{Type} eq "SetGPIO" ) {
        Message("ConfigServer: GetWifiList()")
            if $Verbose;
        $Request->{Error} = "No error.";

# print Data::Dumper->Dump([$Request->{State}],[qw(IWList)]);
        }

    #
    # GetGPIO - Get a GPIOvalue (output or input)
    #
    elsif( $Request->{Type} eq "GetGPIO" ) {
        Message("ConfigServer: GetWifiList()")
            if $Verbose;
        $Request->{Error} = "No error.";

# print Data::Dumper->Dump([$Request->{State}],[qw(IWList)]);
        }

    #
    # Unknown request type: Return error to caller
    #
    else {
        Message("ConfigServer: Unknown request type ($Request->{Type})")
            if $Verbose;
        }

    #
    # Pack up the error message and return the struct to the caller
    #
    SendResponse($Conn,$Request);
    }


########################################################################################################################
########################################################################################################################
#
# GetGPIOConfig - Set up a local config struct with all the information the server needs.
#
# Inputs:      None.
#
# Outputs:     GPIOConfig struct.
#
sub GetGPIOConfig {
    my $GPIOConfig;

    return { Valid => 0 }
        unless -r $GPIOConfigFile;

    my $ConfigFile = Site::ParseData->new(Filename => $GPIOConfigFile, Matches  => $GPIOMatches);
    my $GPIOInfo   = $ConfigFile->ParseFile();
    $GPIOInfo->{Valid} = $ConfigFile->{Parsed};

# use Data::Dumper;
# print Data::Dumper->Dump([$WPAInfo],[qw(WPAInfo)]);

    return $GPIOInfo;
    }

########################################################################################################################
########################################################################################################################
#
# SetGPIOConfig - Set a new GPIO config
#
# Inputs:      Requested config state
#              Original  config state (for comparison)
#              TRUE if verbose mode
#
# Outputs:     None
#
sub SetGPIOConfig {
    my $NewState  = shift;
    my $OrigState = shift;
    my $Verbose   = shift;


#     print Data::Dumper->Dump([$NewState],["NewConfig"])
#         if $Verbose;

    }
